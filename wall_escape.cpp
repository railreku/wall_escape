#include "DxLib.h"
//#define ENEMYCNT 10

typedef struct{
        int x,y,img,muki,walking_flag,now_x,now_y,life,MP;
}ch_t;

typedef struct{
		int x,y,img,muki,walking_flag,now_x,now_y,enemy_on,stop_count;
}ch_teki;

typedef struct{
		int hantei[15][20],taikyu[15][20],chara[15][20];
}map_state;

typedef struct{
	int image[16],teki[16],chara_data[4],wall[6],dagage[1],item[6],eve[4];
}gazou_data;

typedef struct{
	int sound[3];
}sound_data;

int clear_flag[6] = {0,0,0,0,0,0};

int stock = 3;//残り残機

map_state * map;

gazou_data gazou={//画像格納用構造体
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0},
	{0,0,0,0,0,0},
	{0},
	{0,0,0,0,0,0}
};
sound_data sound={0,0,0};//音楽格納用構造体

map_state map0={{//start画面
        { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
        { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 },
        { 1,0,5,5,5,0,0,0,5,5,5,0,0,0,5,5,5,0,0,1 },
        { 1,0,5,9,5,0,0,0,5,10,5,0,0,0,5,11,5,0,0,1 },
        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 },
        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 },
        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 },
        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 },
        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 },
        { 1,0,5,5,5,0,0,0,5,5,5,0,0,0,5,5,5,0,0,1 },
        { 1,0,5,12,5,0,0,0,5,13,5,0,0,0,5,14,5,0,0,1 },
        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 },
        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 },
        { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
},{
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
},{
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		}};
map_state map1={{//ステージ1
        { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
        { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
        { 1,0,0,0,0,5,0,0,0,0,0,0,0,0,5,0,0,0,0,1 },
        { 1,0,0,0,5,0,0,0,0,0,0,0,0,0,0,5,0,0,0,1 },
        { 1,0,0,5,0,0,0,0,0,0,4,0,0,0,0,0,5,0,0,1 },
        { 1,0,5,0,0,20,0,0,0,0,0,0,0,0,0,0,0,5,0,1 },
        { 1,5,0,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,5,1 },
        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 },
        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 },
        { 1,5,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,5,1 },
        { 1,0,5,0,0,2,0,0,0,0,0,0,0,0,0,2,0,5,0,1 },
        { 1,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,1 },
        { 1,0,0,0,5,0,0,0,0,0,0,0,0,0,0,5,0,0,0,1 },
        { 1,0,0,0,0,5,0,0,0,0,0,0,0,0,5,0,0,0,0,1 },
        { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
},{
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
},{
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		}};
map_state map2={{//ステージ2
        { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
        { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
        { 1,5,5,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,1 },
        { 1,5,5,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,1 },
        { 1,5,5,2,2,2,2,2,2,2,2,2,2,2,2,2,2,5,5,1 },
        { 1,5,5,2,2,20,2,2,2,2,0,2,2,2,2,2,2,5,5,1 },
        { 1,5,5,2,2,2,2,2,2,2,2,2,2,2,2,2,2,5,5,1 },
        { 1,5,5,2,2,2,2,2,2,2,2,2,2,2,2,2,2,5,5,1 },
        { 1,5,5,2,2,2,2,2,2,2,2,2,2,2,2,2,2,5,5,1 },
        { 1,5,5,3,3,3,3,3,3,3,3,3,3,3,3,3,3,5,5,1 },
        { 1,5,5,3,3,3,3,3,3,3,3,3,3,3,3,3,3,5,5,1 },
        { 1,5,5,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,1 },
        { 1,5,5,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,1 },
        { 1,5,5,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,1 },
        { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
},{
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
},{
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		}};
map_state map3={{//ステージ3
        { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
        { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
        { 1,0,5,0,2,0,5,0,0,5,0,0,0,5,0,0,0,5,0,1 },
        { 1,0,5,0,5,0,5,0,0,5,0,5,0,5,0,5,0,5,0,1 },
        { 1,0,2,0,5,4,5,0,0,5,4,5,3,5,0,5,3,5,0,1 },
        { 1,0,5,0,4,20,2,0,0,2,0,4,0,4,0,3,0,3,0,1 },
        { 1,0,5,0,5,4,5,0,0,5,4,5,3,5,0,5,3,5,0,1 },
        { 1,0,5,0,5,2,5,0,0,5,2,5,0,5,0,5,0,5,0,1 },
        { 1,0,5,0,5,0,5,0,0,5,0,5,0,5,0,5,0,5,0,1 },
        { 1,0,5,0,5,0,5,5,5,5,0,5,0,5,0,5,4,5,0,1 },
        { 1,0,3,0,5,0,3,3,3,0,0,5,0,5,0,3,3,3,0,1 },
        { 1,0,5,5,5,5,5,3,3,5,5,5,0,5,5,5,5,5,0,1 },
        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 },
        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 },
        { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
},{
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
},{
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		}};
map_state map4={{//ステージ4
        { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
        { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
        { 1,0,0,5,0,0,0,0,0,0,0,5,0,0,0,0,0,5,0,1 },
        { 1,0,0,5,0,0,0,5,0,0,0,5,0,0,5,0,0,5,0,1 },
        { 1,0,0,0,0,0,0,5,0,0,0,0,0,0,5,0,0,0,0,1 },
        { 1,5,5,5,5,20,5,5,5,5,0,5,5,5,5,5,5,0,5,1 },
        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 },
        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 },
        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 },
        { 1,0,5,5,5,5,5,0,5,5,5,5,0,5,5,5,5,5,0,1 },
        { 1,0,0,0,5,0,0,0,0,0,0,0,0,0,0,5,0,0,0,1 },
        { 1,0,0,0,5,0,0,0,0,0,0,0,0,0,0,5,0,0,0,1 },
        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 },
        { 1,0,0,0,5,0,0,0,0,0,0,0,0,0,0,5,0,0,0,1 },
        { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
},{
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
},{
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		}};
map_state map5={{//ステージ5
        { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
        { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
        { 1,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,1 },
        { 1,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,1 },
        { 1,2,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,2,1 },
        { 1,0,0,0,0,20,0,0,0,0,0,0,0,0,0,0,0,0,0,1 },
        { 1,2,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,2,1 },
        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 },
        { 1,2,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,2,1 },
        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 },
        { 1,2,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,2,1 },
        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 },
        { 1,2,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,2,1 },
        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 },
        { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
},{
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
},{
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		}};
map_state map6={{//ステージ6
        { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
        { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
        { 1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1 },
        { 1,5,5,4,0,4,0,4,0,4,0,4,0,4,0,4,0,5,5,1 },
        { 1,5,4,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,5,1 },
        { 1,5,4,4,0,20,0,4,0,4,0,4,0,4,0,4,0,4,5,1 },
        { 1,5,4,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,5,1 },
        { 1,5,4,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,5,1 },
        { 1,5,4,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,5,1 },
        { 1,5,4,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,5,1 },
        { 1,5,4,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,5,1 },
        { 1,5,4,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,5,1 },
        { 1,5,5,4,0,4,0,4,0,4,0,4,0,4,0,4,0,5,5,1 },
        { 1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1 },
        { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
},{
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
},{
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		}};
map_state map7={{//ステージ初期化用格納庫
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
},{
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
},{
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
		}};
//マップ宣言＋定義

int can_or_cannot(int x,int y,int muki){//進めるかを判定する
        if(muki==0)//上向きなら
			if((map->hantei[y/32-1][x/32]>0 && map->hantei[y/32-1][x/32]<8)||map->chara[y/32-1][x/32]>0)//進めるか判定
                        return 1;//エラー
        if(muki==1)//左向きなら
                if((map->hantei[y/32][x/32-1]>0 && map->hantei[y/32][x/32-1]<8)||map->chara[y/32][x/32-1]>0)
                        return 1;
        if(muki==2)//下向きなら
                if((map->hantei[y/32+1][x/32]>0 && map->hantei[y/32+1][x/32]<8)||map->chara[y/32+1][x/32]>0)
                        return 1;
        if(muki==3)//右向きなら
                if((map->hantei[y/32][x/32+1]>0 && map->hantei[y/32][x/32+1]<8)||map->chara[y/32][x/32+1]>0)
                        return 1;
        return 0;//正常
}

int set_chara_hantei(int x, int y,int muki){//キャラクターの位置セット
		map->chara[y/32][x/32] = 0;
		if(muki==0){//上向きなら
                map->chara[y/32-1][x/32] = 9;
		}
		if(muki==1){//左向きなら
                map->chara[y/32][x/32-1] = 9;
		}
		if(muki==2){//下向きなら
                map->chara[y/32+1][x/32] = 9;
		}
		if(muki==3){//右向きなら
                map->chara[y/32][x/32+1] = 9;
		}
					
        return 0;//正常
}

int set_teki_hantei(int x, int y,int muki){//キャラクターの位置セット
		map->chara[y/32][x/32] = 0;
		if(muki==0){//上向きなら
                map->chara[y/32-1][x/32] = 8;
		}
		if(muki==1){//左向きなら
                map->chara[y/32][x/32-1] = 8;
		}
		if(muki==2){//下向きなら
                map->chara[y/32+1][x/32] = 8;
		}
		if(muki==3){//右向きなら
                map->chara[y/32][x/32+1] = 8;
		}
				
        return 0;//正常
}

int enemy_attack(int x,int y,int muki){//キャラクター攻撃判定
        if(muki==0)//上向きなら
			if(map->chara[(y+31)/32-1][x/32]==9){//キャラクター隣接か判定
				PlaySoundMem( sound.sound[2] , DX_PLAYTYPE_BACK ) ;
					return 1;//ライフを減らす
			}
        if(muki==1)//左向きなら
			if(map->chara[y/32][(x+31)/32-1]==9){
				PlaySoundMem( sound.sound[2] , DX_PLAYTYPE_BACK ) ;
					return 1;
			}
        if(muki==2)//下向きなら
			if(map->chara[y/32+1][x/32]==9){
				PlaySoundMem( sound.sound[2] , DX_PLAYTYPE_BACK ) ;
					return 1;
			}
        if(muki==3)//右向きなら
			if(map->chara[y/32][x/32+1]==9){
				PlaySoundMem( sound.sound[2] , DX_PLAYTYPE_BACK ) ;
					return 1;
			}
        return 0;//正常
}

int break_box(int x,int y,int muki){//壊せるかを判定する
        if(muki==0)//上向きなら
                if(map->hantei[y/32-1][x/32]>1&&map->hantei[y/32-1][x/32]<5)//壊せる壁か判定
                        return 1;//壊せる
        if(muki==1)//左向きなら
                if(map->hantei[y/32][x/32-1]>1&&map->hantei[y/32][x/32-1]<5)
                        return 1;
        if(muki==2)//下向きなら
                if(map->hantei[y/32+1][x/32]>1&&map->hantei[y/32+1][x/32]<5)
                        return 1;
        if(muki==3)//右向きなら
                if(map->hantei[y/32][x/32+1]>1&&map->hantei[y/32][x/32+1]<5)
                        return 1;
        return 0;//正常
}

int break_box_attack(int x, int y,int muki){//実際に破壊
		if(muki==0){//上向きなら
                map->hantei[y/32-1][x/32] = 0;
		}
		if(muki==1){//左向きなら
                map->hantei[y/32][x/32-1] = 0;
		}
		if(muki==2){//下向きなら
                map->hantei[y/32+1][x/32] = 0;
		}
		if(muki==3){//右向きなら
                map->hantei[y/32][x/32+1] = 0;
		}
		PlaySoundMem( sound.sound[1] , DX_PLAYTYPE_BACK ) ; // 壁破壊効果音のバックグラウンド演奏
        return 0;//正常
}

int break_box_push(int x, int y,int muki){//耐久を削る
		if(muki==0){//上向きなら
                map->taikyu[y/32-1][x/32] = map->taikyu[y/32-1][x/32] -2 ;
		}
		if(muki==1){//左向きなら
                map->taikyu[y/32][x/32-1] = map->taikyu[y/32][x/32-1] -2 ;
		}
		if(muki==2){//下向きなら
                map->taikyu[y/32+1][x/32] = map->taikyu[y/32+1][x/32] -2 ;
		}
		if(muki==3){//右向きなら
                map->taikyu[y/32][x/32+1] = map->taikyu[y/32][x/32+1] -2 ;
		}
        return 0;//正常
}
int break_can_or_cannot(int x,int y,int muki){//壊れるか判定
        if(muki==0)//上向きなら
                if(map->taikyu[y/32-1][x/32]<0)
                        return 1;//壊れる
        if(muki==1)//左向きなら
                if(map->taikyu[y/32][x/32-1]<0)
                        return 1;
        if(muki==2)//下向きなら
                if(map->taikyu[y/32+1][x/32]<0)
                        return 1;
        if(muki==3)//右向きなら
                if(map->taikyu[y/32][x/32+1]<0)
                        return 1;
        return 0;//正常
}

int create_break_box(int x,int y,int muki,int flag){//壁設置関数
		if(muki==0){//上向きなら
			if(flag == 1){
				map->hantei[y/32-1][x/32] = 2;
				map->taikyu[y/32-1][x/32] = 30;
			}
			if(flag == 2){
				map->hantei[y/32-1][x/32] = 3;
				map->taikyu[y/32-1][x/32] = 60;
			}
			if(flag == 3){
				map->hantei[y/32-1][x/32] = 4;
				map->taikyu[y/32-1][x/32] = 110;
			}
		}//破壊壁設置
		if(muki==1){//左向きなら
			if(flag == 1){
				map->hantei[y/32][x/32-1] = 2;
				map->taikyu[y/32][x/32-1] = 30;
			}
			if(flag == 2){
				map->hantei[y/32][x/32-1] = 3;
				map->taikyu[y/32][x/32-1] = 60;
			}
			if(flag == 3){
				map->hantei[y/32][x/32-1] = 4;
				map->taikyu[y/32][x/32-1] = 110;
			}
		}
		if(muki==2){//下向きなら
			if(flag == 1){
				map->hantei[y/32+1][x/32] = 2;
				map->taikyu[y/32+1][x/32] = 30;
			}
			if(flag == 2){
				map->hantei[y/32+1][x/32] = 3;
				map->taikyu[y/32+1][x/32] = 60;
			}
			if(flag == 3){
				map->hantei[y/32+1][x/32] = 4;
				map->taikyu[y/32+1][x/32] = 110;
			}
		}
		if(muki==3){//右向きなら
			if(flag == 1){
				map->hantei[y/32][x/32+1] = 2;
				map->taikyu[y/32][x/32+1] = 30;
			}
			if(flag == 2){
				map->hantei[y/32][x/32+1] = 3;
				map->taikyu[y/32][x/32+1] = 60;
			}
			if(flag == 3){
				map->hantei[y/32][x/32+1] = 4;
				map->taikyu[y/32][x/32+1] = 110;
			}
		}
        return 0;//正常
		
}

int create_box_1(int x,int y,int muki){//弱壁設置
	int create_flag = 0;
	switch(muki){
		case 0: if(map->hantei[y/32-1][x/32]==0){create_break_box(x,y,muki,1); create_flag = 1;}
			break;
		case 1: if(map->hantei[y/32][x/32-1]==0){create_break_box(x,y,muki,1); create_flag = 1;}
			break;
		case 2: if(map->hantei[y/32+1][x/32]==0){create_break_box(x,y,muki,1); create_flag = 1;}
			break;
		case 3: if(map->hantei[y/32][x/32+1]==0){create_break_box(x,y,muki,1); create_flag = 1;}
			break;
		default:
			break;
	}
	if(create_flag == 1){return 1;}//実際に生成したか
	return 0;
}

int create_box_2(int x,int y,int muki){//中壁設置
	int create_flag = 0;
	switch(muki){
		case 0: if(map->hantei[y/32-1][x/32]==0){create_break_box(x,y,muki,2); create_flag = 1;}
			break;
		case 1: if(map->hantei[y/32][x/32-1]==0){create_break_box(x,y,muki,2); create_flag = 1;}
			break;
		case 2: if(map->hantei[y/32+1][x/32]==0){create_break_box(x,y,muki,2); create_flag = 1;}
			break;
		case 3: if(map->hantei[y/32][x/32+1]==0){create_break_box(x,y,muki,2); create_flag = 1;}
			break;
		default:
			break;
	}
	if(create_flag == 1){return 1;}//実際に生成したか
	return 0;
}

int create_box_3(int x,int y,int muki){
	int create_flag = 0;
	switch(muki){
		case 0: if(map->hantei[y/32-1][x/32]==0){create_break_box(x,y,muki,3); create_flag = 1;}
			break;
		case 1: if(map->hantei[y/32][x/32-1]==0){create_break_box(x,y,muki,3); create_flag = 1;}
			break;
		case 2: if(map->hantei[y/32+1][x/32]==0){create_break_box(x,y,muki,3); create_flag = 1;}
			break;
		case 3: if(map->hantei[y/32][x/32+1]==0){create_break_box(x,y,muki,3); create_flag = 1;}
			break;
		default:
			break;
	}
	if(create_flag == 1){return 1;}//実際に生成したか
	return 0;
}

void base_map_draw(void){//基礎画面描写関数
	/*壁を描画*/
	int font_color = GetColor( 255 , 0 , 0 ) ;
	int i,j;
		for(i=0;i<15;i++){
			for(j=0;j<20;j++){
				if(map->hantei[i][j]==1)
                     DrawBox(j*32,i*32,(j+1)*32,(i+1)*32,GetColor(128,128,128),TRUE);
				if(map->hantei[i][j]==2)					//壊せる壁
					DrawGraph(j*32,i*32,gazou.wall[0],TRUE );
				if(map->hantei[i][j]==3)
					DrawGraph(j*32,i*32,gazou.wall[1],TRUE );
				if(map->hantei[i][j]==4)
					DrawGraph(j*32,i*32,gazou.wall[2],TRUE );
				if(map->hantei[i][j]==5)
					DrawGraph(j*32,i*32,gazou.wall[3],TRUE );
				if(map->hantei[i][j]>=9 && map->hantei[i][j]<20)//ワープ
					DrawGraph(j*32,i*32,gazou.wall[4],TRUE );
				if(map->hantei[i][j]==20)//魔方陣
					DrawGraph(j*32,i*32,gazou.wall[5],TRUE );
			}
		}
		DrawGraph( 224 , 32 , gazou.image[8], TRUE ) ;//画像を描画
		DrawFormatString( 250, 45, font_color , "×%d", stock);//残機出力
}
void break_box_hp(void){
	int i,j;
	for(i=0;i<15;i++){//壁耐久初期値挿入処理
		for(j=0;j<20;j++){
			if(map->hantei[i][j]==2)
				map->taikyu[i][j] = 10;
			if(map->hantei[i][j]==3)					
				map->taikyu[i][j] = 50;
			if(map->hantei[i][j]==4)
				map->taikyu[i][j] = 100;
		}
	}
}
/* ****************
		ここから敵移動方向判定
***************** */

int enemy_walking(int x, int y, int enemy_x, int enemy_y){//敵の移動方向規定
	int xrtn = 0 ,yrtn = 0;
	if(x >= enemy_x){
		x -= enemy_x;
	}else{
		x = enemy_x - x;
		xrtn = 1;
	}
	if(y >= enemy_y){
		y -= enemy_y;
	}else{
		y = enemy_y - y;
		yrtn = 1;
	}

	if(x-y >= 0){//横のほうが近い
		if(xrtn == 0){
			return(3);//右
		}else{
			return(1);//左
		}
	}else{//縦のほうが近い
		if(yrtn == 0){
			return(2);//下
		}else{
			return(0);//上
		}
	}
}
/* ****************
		ここまで敵移動方向判定
***************** */


/* ****************
		ここから敵移動
***************** */
int enemy_base(int *ch_x,int *ch_y,int *ch_life,ch_teki *enemy,int *ch_flag){
	int x = *ch_x ,y = *ch_y;
	if(x >= enemy->x){
		x -= enemy->x;
	}else{
		x = enemy->x - x;
	}
	if(y >= enemy->y){
		y -= enemy->y;
	}else{
		y = enemy->y - y;
	}
	if(x<=160&&y<=160){//縦横５マス以内にいたら
		if(enemy->x%32==0 && enemy->y%32==0){//敵移動プログラム
            enemy->walking_flag=1;         //歩くフラグを立てる。
			if     (enemy_walking(*ch_x,*ch_y,enemy->x,enemy->y)==0)  //上に移動フラグなら
                    enemy->muki=0;         //上向きフラグを立てる
            else if(enemy_walking(*ch_x,*ch_y,enemy->x,enemy->y)==1)  //左に移動フラグなら
                    enemy->muki=1;         //左向きフラグを立てる
            else if(enemy_walking(*ch_x,*ch_y,enemy->x,enemy->y)==2)  //下に移動フラグなら
                    enemy->muki=2;         //下向きフラグを立てる
            else if(enemy_walking(*ch_x,*ch_y,enemy->x,enemy->y)==3)  //右に移動フラグなら
                    enemy->muki=3;         //右向きフラグを立てる
            else                                    //何のボタンも押されてなかったら
                    enemy->walking_flag=0; //歩かないフラグを立てる
			if(enemy->walking_flag==1){    //もし歩くなら
				if(can_or_cannot(enemy->x,enemy->y,enemy->muki)==1){//行き先が歩けないなら
                    enemy->walking_flag=0;                  //歩かないフラグを立てる。
				}
				
			}
			if(break_box(enemy->x,enemy->y,enemy->muki)==1){//壁が壊せるか
				break_box_push(enemy->x,enemy->y,enemy->muki);
				if(break_can_or_cannot(enemy->x,enemy->y,enemy->muki)==1)
					break_box_attack(enemy->x,enemy->y,enemy->muki);//壁を壊す
			}
        }
 
        if(enemy->walking_flag==1){        //歩くフラグが立っていたら
			enemy->now_x = enemy->x;
			enemy->now_y = enemy->y;
            if     (enemy->muki==0)        //上向きならch.y座標を減らす
                    enemy->y-=1;
            else if(enemy->muki==1)        //左向きならch.x座標を減らす
                    enemy->x-=1;
            else if(enemy->muki==2)        //下向きならch.y座標を増やす
                    enemy->y+=1;
            else if(enemy->muki==3)        //右向きならch.x座標を増やす
                    enemy->x+=1;
        }
		if(*ch_flag == 0 && (enemy->x%32!=0 || enemy->y%32!=0)){//敵判定用フラグ
			set_teki_hantei(enemy->now_x,enemy->now_y,enemy->muki);
			*ch_flag = 1;
		}
		if(*ch_flag == 1 && (enemy->x%32==0 && enemy->y%32==0)){
			*ch_flag = 0;
		}
		if(enemy_attack(enemy->x,enemy->y,enemy->muki) == 1){//キャラクターダメージ判定
			*ch_life = *ch_life - 1;
			DrawGraph( *ch_x , *ch_y , gazou.dagage[0] , TRUE ) ;//画像を描画
			ScreenFlip();
		}
		if(break_box(enemy->x,enemy->y,enemy->muki)==0 && enemy->walking_flag == 0){//壁にはまっていた場合
			return (1);
		}
		return(0);
	}else{//５マス外ならランダムで移動
		int GetRand( int RandMax ) ;
		if(enemy->x%32==0 && enemy->y%32==0){//敵移動プログラム
            enemy->walking_flag=1;         //歩くフラグを立てる。
                    enemy->muki= GetRand( 3 );         //上向きフラグを立てる
				if(can_or_cannot(enemy->x,enemy->y,enemy->muki)==1){//行き先が歩けないなら
                    enemy->walking_flag=0;                  //歩かないフラグを立てる。
				}
				
			}
			if(break_box(enemy->x,enemy->y,enemy->muki)==1){//壁が壊せるか
				break_box_push(enemy->x,enemy->y,enemy->muki);
				if(break_can_or_cannot(enemy->x,enemy->y,enemy->muki)==1)
					break_box_attack(enemy->x,enemy->y,enemy->muki);//壁を壊す
			}
        }
 
        if(enemy->walking_flag==1){        //歩くフラグが立っていたら
			enemy->now_x = enemy->x;
			enemy->now_y = enemy->y;
            if     (enemy->muki==0)        //上向きならch.y座標を減らす
                    enemy->y-=1;
            else if(enemy->muki==1)        //左向きならch.x座標を減らす
                    enemy->x-=1;
            else if(enemy->muki==2)        //下向きならch.y座標を増やす
                    enemy->y+=1;
            else if(enemy->muki==3)        //右向きならch.x座標を増やす
                    enemy->x+=1;
        }
		if(*ch_flag == 0 && (enemy->x%32!=0 || enemy->y%32!=0)){//敵判定用フラグ
			set_teki_hantei(enemy->now_x,enemy->now_y,enemy->muki);
			*ch_flag = 1;
		}
		if(*ch_flag == 1 && (enemy->x%32==0 && enemy->y%32==0)){
			*ch_flag = 0;
		}
		if(enemy_attack(enemy->x,enemy->y,enemy->muki) == 1){//キャラクターダメージ判定
			*ch_life = *ch_life - 1;
		}
		return(0);
}
/* ****************
		ここまで敵移動
***************** */

int enemy_rand_walk(int *ch_x,int *ch_y,int *ch_life,ch_teki *enemy,int *ch_flag){//ランダム移動
	int GetRand( int RandMax ) ;
	if(enemy->x%32==0 && enemy->y%32==0){//敵移動プログラム
        enemy->walking_flag=1;         //歩くフラグを立てる。
        enemy->muki= GetRand( 3 );         //上向きフラグを立てる
		if(can_or_cannot(enemy->x,enemy->y,enemy->muki)==1){//行き先が歩けないなら
             enemy->walking_flag=0;                  //歩かないフラグを立てる。
		}
				
	}
	if(break_box(enemy->x,enemy->y,enemy->muki)==1){//壁が壊せるか
		break_box_push(enemy->x,enemy->y,enemy->muki);
		if(break_can_or_cannot(enemy->x,enemy->y,enemy->muki)==1)
			break_box_attack(enemy->x,enemy->y,enemy->muki);//壁を壊す
    }
 
    if(enemy->walking_flag==1){        //歩くフラグが立っていたら
		enemy->now_x = enemy->x;
		enemy->now_y = enemy->y;
        if(enemy->muki==0)        //上向きならch.y座標を減らす
            enemy->y-=1;
        else if(enemy->muki==1)        //左向きならch.x座標を減らす
            enemy->x-=1;
        else if(enemy->muki==2)        //下向きならch.y座標を増やす
            enemy->y+=1;
        else if(enemy->muki==3)        //右向きならch.x座標を増やす
            enemy->x+=1;
    }
	if(*ch_flag == 0 && (enemy->x%32!=0 || enemy->y%32!=0)){//敵判定用フラグ
		set_teki_hantei(enemy->now_x,enemy->now_y,enemy->muki);
		*ch_flag = 1;
	}
	if(*ch_flag == 1 && (enemy->x%32==0 && enemy->y%32==0)){
		*ch_flag = 0;
	}
	if(enemy_attack(enemy->x,enemy->y,enemy->muki) == 1){//キャラクターダメージ判定
		*ch_life = *ch_life - 1;
	}
	return(0);
}

void game_over(int *ch_x,int *ch_y,int *ch_muki,int *ch_img,int *ch_life,int *ch_MP,int *font_color,int *end_time,int *now_time,ch_teki enemy[10]){
	char Key[256];
	ch_teki *ene;
	ene = enemy;
	while(!ProcessMessage() && !ClearDrawScreen() && !GetHitKeyStateAll( Key ) && !Key[KEY_INPUT_ESCAPE] && !Key[KEY_INPUT_A]){
			int i;
			base_map_draw();
				
			for(i=0;i<*ch_life/10;i++){DrawGraph(32+18*i,32,gazou.chara_data[0],TRUE );}//体力ゲージ
			for(i=9;i>=*ch_life/10;i--){DrawGraph(32+18*i,32,gazou.chara_data[1],TRUE );}//体力ゲージ枠
			for(i=0;i<*ch_MP;i++){DrawGraph(32+18*i,48,gazou.chara_data[2],TRUE );}//MPゲージ
			for(i=9;i>=*ch_MP;i--){DrawGraph(32+18*i,48,gazou.chara_data[3],TRUE );}//MPゲージ

			DrawFormatString( 500, 32, *font_color, "TIME:%d秒", (*end_time - *now_time));//時間表示
			SetFontSize( 18 ) ;
			*font_color = GetColor( 255 , 0 , 0 ) ;
			*ch_img=gazou.image[(*ch_x%32+*ch_y%32)/8 + *ch_muki*4];            //画像をセット
 	        DrawGraph( *ch_x , *ch_y , *ch_img , TRUE ) ;//画像を描画
			for(i=0;i<10;i++){
				if((ene+i)->enemy_on == 1){//enemy[i]がでていれば描写
					(ene+i)->img=gazou.teki[((ene+i)->x%32+(ene+i)->y%32)/8 + (ene+i)->muki*4];
					DrawGraph( (ene+i)->x , (ene+i)->y , (ene+i)->img , TRUE ) ;
				}
			}
			DrawGraph(60,160,gazou.eve[3],TRUE );
			ScreenFlip();
	}
	return;
}

int stage_clear(int *ch_x,int *ch_y,int *ch_muki,int *ch_img,int *ch_life,int *ch_MP,int *font_color,int *end_time,int *now_time,int *clear_flag,ch_teki enemy[10]){
	char Key[256];
	ch_teki *ene;
	ene = enemy;
	while(!ProcessMessage() && !ClearDrawScreen() && !GetHitKeyStateAll( Key ) && !Key[KEY_INPUT_ESCAPE] && *clear_flag == 0){
			int i;
			base_map_draw();
				
			for(i=0;i<=*ch_life/10;i++){DrawGraph(32+18*i,32,gazou.chara_data[0],TRUE );}//体力ゲージ
			for(i=9;i>*ch_life/10;i--){DrawGraph(32+18*i,32,gazou.chara_data[1],TRUE );}//体力ゲージ枠
			for(i=0;i<*ch_MP;i++){DrawGraph(32+18*i,48,gazou.chara_data[2],TRUE );}//MPゲージ
			for(i=9;i>=*ch_MP;i--){DrawGraph(32+18*i,48,gazou.chara_data[3],TRUE );}//MPゲージ

			DrawFormatString( 500, 32, *font_color, "TIME:%d秒", (*end_time - *now_time));//時間表示
			SetFontSize( 18 ) ;
			*font_color = GetColor( 255 , 255 , 0 ) ;
			*ch_img=gazou.image[(*ch_x%32+*ch_y%32)/8 + *ch_muki*4];            //画像をセット
 	        DrawGraph( *ch_x , *ch_y , *ch_img , TRUE ) ;//画像を描画
			for(i=0;i<10;i++){
				if((ene+i)->enemy_on == 1){//enemy[i]がでていれば描写
					(ene+i)->img=gazou.teki[((ene+i)->x%32+(ene+i)->y%32)/8 + (ene+i)->muki*4];
					DrawGraph( (ene+i)->x , (ene+i)->y , (ene+i)->img , TRUE ) ;
				}
			}
			if(Key[KEY_INPUT_A] == 1){
					*clear_flag = 1;
			}
			DrawGraph(180,160,gazou.eve[0],TRUE );
			ScreenFlip();
	}
	return(0);
}
int pause(int *ch_x,int *ch_y,int *ch_muki,int *ch_img,int *ch_life,int *ch_MP,int *font_color,int *end_time,int *now_time,ch_teki enemy[10]){//一時中断
	char Key[256];
	int i,count_time,time;
	count_time = *end_time - *now_time;
	ch_teki *ene;
	ene = enemy;
	WaitTimer(200);

	while(!ProcessMessage() && !ClearDrawScreen() && !GetHitKeyStateAll( Key ) && !Key[KEY_INPUT_ESCAPE] && !Key[KEY_INPUT_P]){
			time = (GetNowCount()/1000);
			base_map_draw();
				
			for(i=0;i<=*ch_life/10;i++){DrawGraph(32+18*i,32,gazou.chara_data[0],TRUE );}//体力ゲージ
			for(i=9;i>*ch_life/10;i--){DrawGraph(32+18*i,32,gazou.chara_data[1],TRUE );}//体力ゲージ枠
			for(i=0;i<*ch_MP;i++){DrawGraph(32+18*i,48,gazou.chara_data[2],TRUE );}//MPゲージ
			for(i=9;i>=*ch_MP;i--){DrawGraph(32+18*i,48,gazou.chara_data[3],TRUE );}//MPゲージ

			DrawFormatString( 500, 32, *font_color, "TIME:%d秒", (*end_time - *now_time));//時間表示
			SetFontSize( 18 ) ;
			*font_color = GetColor( 255 , 0 , 0 ) ;
			DrawString( 150 , 224 , "[PAUSE] Pキーで戻ります" , *font_color);

			*ch_img=gazou.image[(*ch_x%32+*ch_y%32)/8 + *ch_muki*4];            //画像をセット
 	        DrawGraph( *ch_x , *ch_y , *ch_img , TRUE ) ;//画像を描画
			for(i=0;i<10;i++){
				if((ene+i)->enemy_on == 1){//enemy[i]がでていれば描写
					(ene+i)->img=gazou.teki[((ene+i)->x%32+(ene+i)->y%32)/8 + (ene+i)->muki*4];
					DrawGraph( (ene+i)->x , (ene+i)->y , (ene+i)->img , TRUE ) ;
				}
			}
			ScreenFlip();
	}
	*now_time = time;
	*end_time = *now_time + count_time;
	return(0);
}

int stage(int HP,int stage_no);

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,LPSTR lpCmdLine, int nCmdShow ){
	int i;
	int tenkan,tenkan_wait;
	int font_color;
	int ch_flag[2]={0,0};//キャラ移動判定フラグ
    char Key[256];
    ch_t ch;
	int MP_heal_c;

	map = &map0;
 
    if( ChangeWindowMode(TRUE) != DX_CHANGESCREEN_OK || DxLib_Init() == -1 ) return -1; //ウィンドウ化と初期化処理	
 
    ch.x    =288;
    ch.y    =288;
    ch.walking_flag=0;
    ch.muki=0;
	tenkan_wait = 0; 
	tenkan = ch.muki;
	ch.now_x = ch.x;//32刻みでの現在地確保
	ch.now_y = ch.y;//32刻みでの現在地確保
	ch.life =90;//体力
	ch.MP = 10;//魔力
	MP_heal_c = 0;
	map->chara[ch.now_y/32][ch.now_x/32] = 9;//mapへの自キャラ初期配置

	font_color = GetColor( 255 , 255 , 0 ) ;

	break_box_hp();//壁耐久値代入関数

    SetDrawScreen( DX_SCREEN_BACK ) ;                                                 //描画先を裏画面に設定
    LoadDivGraph( "gazou/@chara01_a.png" , 16 , 4 , 4 , 28 , 32 , gazou.image ) ;//画像を分割してimage配列に保存
	LoadDivGraph( "gazou/char.png" , 16 , 4 , 4 , 32 , 32 , gazou.teki );
	gazou.chara_data[0] = LoadGraph( "gazou/ハート.png" ) ;//体力ゲージ画像読み込み
	gazou.chara_data[1] = LoadGraph( "gazou/ハート枠.png" ) ;//体力ゲージ枠画像読み込み
	gazou.chara_data[2] = LoadGraph( "gazou/霊力.png" ) ;//MPゲージ画像読み込み
	gazou.chara_data[3] = LoadGraph( "gazou/霊力枠.png" ) ;//MPゲージ画像読み込み
	gazou.wall[0] = LoadGraph( "gazou/壊れru.png" ) ;//壁
	gazou.wall[1] = LoadGraph( "gazou/壊れru2.png" ) ;
	gazou.wall[2] = LoadGraph( "gazou/壊れru3.png" ) ;
	gazou.wall[3] = LoadGraph( "gazou/壊れない壁.png" ) ;
	gazou.wall[4] = LoadGraph( "gazou/ワープ.png" ) ;
	gazou.wall[5] = LoadGraph( "gazou/魔法陣.png" ) ;//
	gazou.dagage[0] = LoadGraph( "gazou/@damage2.png" ) ;//ダメージエフェクト
	gazou.item[0] = LoadGraph( "gazou/rtst.png" ) ;//アイテム
	gazou.item[1] = LoadGraph( "gazou/gtst.png" ) ;
	gazou.item[2] = LoadGraph( "gazou/ytst.png" ) ;
	gazou.item[3] = LoadGraph( "gazou/btst.png" ) ;
	gazou.item[4] = LoadGraph( "gazou/stst2.png" ) ;
	gazou.item[5] = LoadGraph( "gazou/ptst.png" ) ;
	gazou.eve[0] = LoadGraph( "gazou/clear.png" ) ;
	gazou.eve[1] = LoadGraph( "gazou/a_clear.png" ) ;
	gazou.eve[2] = LoadGraph( "gazou/gameover.png" ) ;
	gazou.eve[3] = LoadGraph( "gazou/gameover_o.png" ) ;
	sound.sound[0] = LoadSoundMem( "sound/bgm_maoudamashii_piano05.mp3" );      //wavファイルを読み込み、ハンドルをint型変数へ格納
	sound.sound[1] = LoadSoundMem( "sound/se_maoudamashii_battle18.wav" );      //wavファイルを読み込み、ハンドルをint型変数へ格納
	sound.sound[2] = LoadSoundMem( "sound/se_maoudamashii_se_sound12.wav" );      //wavファイルを読み込み、ハンドルをint型変数へ格納
	SetFontSize( 18 ) ;

	break_box_hp();//壁耐久値代入関数

	PlaySoundMem( sound.sound[0] , DX_PLAYTYPE_LOOP);//BGM再生
	
    while(!ProcessMessage() && !ClearDrawScreen() && !GetHitKeyStateAll( Key ) && !Key[KEY_INPUT_ESCAPE]){
            //↑ﾒｯｾｰｼﾞ処理        ↑画面をｸﾘｱ         ↑ｷｰﾎﾞｰﾄﾞ入力状態取得       ↑ESCが押されると終了
 
			base_map_draw();
			
			for(i=0;i<=ch.life/10;i++){DrawGraph(32+18*i,32,gazou.chara_data[0],TRUE );}//体力ゲージ
			for(i=9;i>ch.life/10;i--){DrawGraph(32+18*i,32,gazou.chara_data[1],TRUE );}//体力ゲージ枠
			for(i=0;i<ch.MP;i++){DrawGraph(32+18*i,48,gazou.chara_data[2],TRUE );}//MPゲージ
			for(i=9;i>=ch.MP;i--){DrawGraph(32+18*i,48,gazou.chara_data[3],TRUE );}//MPゲージ

            if(ch.x%32==0 && ch.y%32==0){         //座標が32で割り切れたら入力可能
				ch.walking_flag=1;         //歩くフラグを立てる。
				if     ( Key[ KEY_INPUT_UP   ]  == 1 )  //上ボタンが押されたら
				       ch.muki=0;         //上向きフラグを立てる
				else if( Key[ KEY_INPUT_LEFT ]  == 1 )  //左ボタンが押されたら
                    ch.muki=1;         //左向きフラグを立てる
				else if( Key[ KEY_INPUT_DOWN ]  == 1 )  //下ボタンが押されたら
                    ch.muki=2;         //下向きフラグを立てる
				else if( Key[ KEY_INPUT_RIGHT]  == 1 )  //右ボタンが押されたら
                    ch.muki=3;         //右向きフラグを立てる
				else                                    //何のボタンも押されてなかったら
                    ch.walking_flag=0; //歩かないフラグを立てる
				if(ch.walking_flag==1){    //もし歩くなら
					if(can_or_cannot(ch.x,ch.y,ch.muki)==1){//行き先が歩けないなら
						ch.walking_flag=0;                  //歩かないフラグを立てる。
					}
				}
			if(break_box(ch.x,ch.y,ch.muki)==1 && (Key[KEY_INPUT_UP]==1||Key[KEY_INPUT_LEFT]==1||Key[KEY_INPUT_DOWN]==1||Key[KEY_INPUT_RIGHT]==1)){//壁が壊せるか
				break_box_push(ch.x,ch.y,ch.muki);
				if(break_can_or_cannot(ch.x,ch.y,ch.muki)==1)
					break_box_attack(ch.x,ch.y,ch.muki);//壁を壊す
			}
			}			
			
			if(ch.muki != tenkan && tenkan_wait<=0){//方向転換処理
				tenkan = ch.muki;
				ch.walking_flag = 0;
				tenkan_wait = 4;
			}else if(tenkan_wait>0){ch.walking_flag = 0;tenkan_wait--;}
 
        if(ch.walking_flag==1){        //歩くフラグが立っていたら
			ch.now_x = ch.x;
			ch.now_y = ch.y;
            if     (ch.muki==0)        //上向きならch.y座標を減らす
                    ch.y-=2;
            else if(ch.muki==1)        //左向きならch.x座標を減らす
                    ch.x-=2;
            else if(ch.muki==2)        //下向きならch.y座標を増やす
                    ch.y+=2;
            else if(ch.muki==3)        //右向きならch.x座標を増やす
                    ch.x+=2;
        }
		if(ch_flag[0] == 0 && (ch.x%32!=0 || ch.y%32!=0)){//キャラ判定用フラグ
			set_chara_hantei(ch.now_x,ch.now_y,ch.muki);
			ch_flag[0] = 1;
		}
		if(ch_flag[0] == 1 && (ch.x%32==0 && ch.y%32==0)){
			ch_flag[0] = 0;
		}
		
		if(MP_heal_c >0){MP_heal_c --;}//MP回復カウント

		if(MP_heal_c <= 0 && ch.MP <10){ch.MP ++; MP_heal_c =25;}//MP回復

		if(map->chara[ch.now_y/32][ch.now_x/32] == 9 && map->hantei[ch.now_y/32][ch.now_x/32] == 9){//ワープ処理stage1
			map7 = map1;
			ch.life = stage(ch.life,1);
			if(clear_flag[0]==1)map->hantei[ch.now_y/32+1][ch.now_x/32] = 5;
			map->chara[ch.now_y/32][ch.now_x/32] = 0;
			/*座標クリア*/
			ch.x    =288;
			ch.y    =288;
			ch.walking_flag=0;
			ch.muki=0;
			tenkan_wait = 0; 
			tenkan = ch.muki;
			ch.now_x = ch.x;//32刻みでの現在地確保
			ch.now_y = ch.y;//32刻みでの現在地確保
			map->chara[ch.now_y/32][ch.now_x/32] = 9;//mapへの自キャラ初期配置
		}
		if(map->chara[ch.now_y/32][ch.now_x/32] == 9 && map->hantei[ch.now_y/32][ch.now_x/32] == 10){//ワープ処理stage2
			map7 = map2;
			ch.life = stage(ch.life,2);
			if(clear_flag[1]==1)map->hantei[ch.now_y/32+1][ch.now_x/32] = 5;
			map->chara[ch.now_y/32][ch.now_x/32] = 0;
			/*座標クリア*/
			ch.x    =288;
			ch.y    =288;
			ch.walking_flag=0;
			ch.muki=0;
			tenkan_wait = 0; 
			tenkan = ch.muki;
			ch.now_x = ch.x;//32刻みでの現在地確保
			ch.now_y = ch.y;//32刻みでの現在地確保
			map->chara[ch.now_y/32][ch.now_x/32] = 9;//mapへの自キャラ初期配置
		}
		if(map->chara[ch.now_y/32][ch.now_x/32] == 9 && map->hantei[ch.now_y/32][ch.now_x/32] == 11){//ワープ処理stage3
			map7 = map3;
			ch.life = stage(ch.life,3);
			if(clear_flag[2]==1)map->hantei[ch.now_y/32+1][ch.now_x/32] = 5;
			map->chara[ch.now_y/32][ch.now_x/32] = 0;
			/*座標クリア*/
			ch.x    =288;
			ch.y    =288;
			ch.walking_flag=0;
			ch.muki=0;
			tenkan_wait = 0; 
			tenkan = ch.muki;
			ch.now_x = ch.x;//32刻みでの現在地確保
			ch.now_y = ch.y;//32刻みでの現在地確保
			map->chara[ch.now_y/32][ch.now_x/32] = 9;//mapへの自キャラ初期配置
		}
		if(map->chara[ch.now_y/32][ch.now_x/32] == 9 && map->hantei[ch.now_y/32][ch.now_x/32] == 12){//ワープ処理stage4
			map7 = map4;
			ch.life = stage(ch.life,4);
			if(clear_flag[3]==1)map->hantei[ch.now_y/32+1][ch.now_x/32] = 5;
			map->chara[ch.now_y/32][ch.now_x/32] = 0;
			/*座標クリア*/
			ch.x    =288;
			ch.y    =288;
			ch.walking_flag=0;
			ch.muki=0;
			tenkan_wait = 0; 
			tenkan = ch.muki;
			ch.now_x = ch.x;//32刻みでの現在地確保
			ch.now_y = ch.y;//32刻みでの現在地確保
			map->chara[ch.now_y/32][ch.now_x/32] = 9;//mapへの自キャラ初期配置
		}
		if(map->chara[ch.now_y/32][ch.now_x/32] == 9 && map->hantei[ch.now_y/32][ch.now_x/32] == 13){//ワープ処理stage5
			map7 = map5;
			ch.life = stage(ch.life,5);
			if(clear_flag[4]==1)map->hantei[ch.now_y/32+1][ch.now_x/32] = 5;
			map->chara[ch.now_y/32][ch.now_x/32] = 0;
			/*座標クリア*/
			ch.x    =288;
			ch.y    =288;
			ch.walking_flag=0;
			ch.muki=0;
			tenkan_wait = 0; 
			tenkan = ch.muki;
			ch.now_x = ch.x;//32刻みでの現在地確保
			ch.now_y = ch.y;//32刻みでの現在地確保
			map->chara[ch.now_y/32][ch.now_x/32] = 9;//mapへの自キャラ初期配置
		}
		if(map->chara[ch.now_y/32][ch.now_x/32] == 9 && map->hantei[ch.now_y/32][ch.now_x/32] == 14){//ワープ処理stage6
			map7 = map6;
			ch.life = stage(ch.life,6);
			if(clear_flag[5]==1)map->hantei[ch.now_y/32+1][ch.now_x/32] = 5;
			map->chara[ch.now_y/32][ch.now_x/32] = 0;
			/*座標クリア*/
			ch.x    =288;
			ch.y    =288;
			ch.walking_flag=0;
			ch.muki=0;
			tenkan_wait = 0; 
			tenkan = ch.muki;
			ch.now_x = ch.x;//32刻みでの現在地確保
			ch.now_y = ch.y;//32刻みでの現在地確保
			map->chara[ch.now_y/32][ch.now_x/32] = 9;//mapへの自キャラ初期配置
		}
		if(Key[ KEY_INPUT_Z] == 1 && ch.x%32==0 && ch.y%32==0 && ch.MP >= 1){//弱壁設置 壁じゃないとき置けるようにすること　MP消費実装
			ch.now_x = ch.x;
			ch.now_y = ch.y;
			if(create_box_1(ch.now_x,ch.now_y,ch.muki) == 1){
				ch.MP --;
				MP_heal_c = 50;
			}
		}
		if(Key[ KEY_INPUT_X] == 1 && ch.x%32==0 && ch.y%32==0 && ch.MP >= 2){//中壁設置 壁じゃないとき置けるようにすること　MP消費実装
			ch.now_x = ch.x;
			ch.now_y = ch.y;
			if(create_box_2(ch.now_x,ch.now_y,ch.muki) == 1){
				ch.MP = ch.MP - 2;
				MP_heal_c = 100;
			}
		}
		if(Key[ KEY_INPUT_C] == 1 && ch.x%32==0 && ch.y%32==0 && ch.MP >= 3){//強壁設置 壁じゃないとき置けるようにすること　MP消費実装
			ch.now_x = ch.x;
			ch.now_y = ch.y;
			if(create_box_3(ch.now_x,ch.now_y,ch.muki) == 1){
				ch.MP = ch.MP - 3;
				MP_heal_c = 150;
			}
		}
		if(clear_flag[0] == 1&&clear_flag[1] == 1&&clear_flag[2] == 1&&clear_flag[3] == 1&&clear_flag[4] == 1&&clear_flag[5] == 1){//クリア判定
			while(!ProcessMessage() && !ClearDrawScreen() && !GetHitKeyStateAll( Key ) && !Key[KEY_INPUT_ESCAPE]){
				base_map_draw();

				for(i=0;i<=ch.life/10;i++){DrawGraph(32+18*i,32,gazou.chara_data[0],TRUE );}//体力ゲージ
				for(i=9;i>ch.life/10;i--){DrawGraph(32+18*i,32,gazou.chara_data[1],TRUE );}//体力ゲージ枠
				for(i=0;i<ch.MP;i++){DrawGraph(32+18*i,48,gazou.chara_data[2],TRUE );}//MPゲージ
				for(i=9;i>=ch.MP;i--){DrawGraph(32+18*i,48,gazou.chara_data[3],TRUE );}//MPゲージ

				SetFontSize( 28 ) ;
				font_color = GetColor( 255 , 255 , 0 ) ;

				ch.img=gazou.image[(ch.x%32+ch.y%32)/8 + ch.muki*4];            //画像をセット
 
		        DrawGraph( ch.x , ch.y , ch.img , TRUE ) ;//画像を描画
				DrawGraph(120,160,gazou.eve[1],TRUE );
				ScreenFlip();
			}
			break;
		}
		if(stock < 0){//ゲームオーバー判定
			while(!ProcessMessage() && !ClearDrawScreen() && !GetHitKeyStateAll( Key ) && !Key[KEY_INPUT_ESCAPE]){
				base_map_draw();

				for(i=0;i<=ch.life/10;i++){DrawGraph(32+18*i,32,gazou.chara_data[0],TRUE );}//体力ゲージ
				for(i=9;i>ch.life/10;i--){DrawGraph(32+18*i,32,gazou.chara_data[1],TRUE );}//体力ゲージ枠
				for(i=0;i<ch.MP;i++){DrawGraph(32+18*i,48,gazou.chara_data[2],TRUE );}//MPゲージ
				for(i=9;i>=ch.MP;i--){DrawGraph(32+18*i,48,gazou.chara_data[3],TRUE );}//MPゲージ

				SetFontSize( 28 ) ;
				font_color = GetColor( 255 , 255 , 0 ) ;

				ch.img=gazou.image[(ch.x%32+ch.y%32)/8 + ch.muki*4];            //画像をセット
 
		        DrawGraph( ch.x , ch.y , ch.img , TRUE ) ;//画像を描画
				DrawGraph(40,160,gazou.eve[2],TRUE );
				ScreenFlip();
			}
			DxLib_End();
		}
		ch.img=gazou.image[(ch.x%32+ch.y%32)/8 + ch.muki*4];            //画像をセット

        DrawGraph( ch.x , ch.y , ch.img , TRUE ) ;//画像を描画
 
        ScreenFlip();
    }
 
    DxLib_End();
    return 0;
}

int stage(int HP,int stage_no){
	int i;
	int tenkan,tenkan_wait;//向き変更処理用停止時間
	int font_color;
	int ch_flag[11]={0,0,0,0,0,0,0,0,0,0,0};//ランダム移動用フラグ
    char Key[256];//キー入力変数
    ch_t ch;//自キャラ構造体定義
	int time_stop_flag = 0;//時間停止＆クリアアイテム出現

	ch_teki enemy[10];//敵配列定義
	ch_teki *ene;//敵配列用ポインタ
	ene = enemy;
	int MP_heal_c;//MP回復時間カウント
	int now_time,end_time;//時間計算
	switch(stage_no){
		case 1:map = &map1; break;
		case 2:map = &map2;	break;
		case 3:map = &map3;	break;
		case 4:map = &map4;	break;
		case 5:map = &map5;	break;
		case 6:map = &map6;	break;
	}

	ch.x    =320;
    ch.y    =160;
    ch.walking_flag=0;
    ch.muki=2;
	tenkan_wait = 0; 
	tenkan = ch.muki;
	ch.now_x = ch.x;//32刻みでの現在地確保
	ch.now_y = ch.y;//32刻みでの現在地確保
	ch.life = HP;
	ch.MP = 10;
	MP_heal_c = 0;
	map->chara[ch.now_y/32][ch.now_x/32] = 9;//mapへの自キャラ初期配置
	
	for(i=0;i<10;i++){
		(ene+i)->x = 160;
		(ene+i)->y = 160;
		(ene+i)->walking_flag = 0;
		(ene+i)->muki = 2;
		(ene+i)->now_x = (ene+i)->x;//32刻みでの現在地確保
		(ene+i)->now_y = (ene+i)->y;//32刻みでの現在地確保
		(ene+i)->enemy_on = 0;//出現フラグ
		(ene+i)->stop_count = 0;//壁ハメ判定用カウント
	}

    SetDrawScreen( DX_SCREEN_BACK ) ;          //描画先を裏画面に設定

	now_time = (GetNowCount()/1000);
	end_time = (now_time + 120);//クリア時間指定

	SetFontSize( 18 ) ;
	
	break_box_hp();//壁耐久値代入関数

    while(!ProcessMessage() && !ClearDrawScreen() && !GetHitKeyStateAll( Key ) && !Key[KEY_INPUT_ESCAPE] && clear_flag[stage_no-1]==0){
            //↑ﾒｯｾｰｼﾞ処理        ↑画面をｸﾘｱ         ↑ｷｰﾎﾞｰﾄﾞ入力状態取得       ↑ESCが押されると終了
 
                base_map_draw();
				
				for(i=0;i<=ch.life/10;i++){DrawGraph(32+18*i,32,gazou.chara_data[0],TRUE );}//体力ゲージ
				for(i=9;i>ch.life/10;i--){DrawGraph(32+18*i,32,gazou.chara_data[1],TRUE );}//体力ゲージ枠
				for(i=0;i<ch.MP;i++){DrawGraph(32+18*i,48,gazou.chara_data[2],TRUE );}//MPゲージ
				for(i=9;i>=ch.MP;i--){DrawGraph(32+18*i,48,gazou.chara_data[3],TRUE );}//MPゲージ
				if(time_stop_flag == 0){
					if(end_time>=now_time){now_time = (GetNowCount()/1000);}
					font_color = GetColor( 255 , 0 , 0 ) ;
				}
				DrawFormatString( 500, 32, font_color, "TIME:%d秒", (end_time - now_time)) ;//時間表示
            if(ch.x%32==0 && ch.y%32==0){         //座標が32で割り切れたら入力可能
				ch.walking_flag=1;         //歩くフラグを立てる。
				if( Key[ KEY_INPUT_UP   ]  == 1 )  //上ボタンが押されたら
				       ch.muki=0;         //上向きフラグを立てる
				else if( Key[ KEY_INPUT_LEFT ]  == 1 )  //左ボタンが押されたら
                    ch.muki=1;         //左向きフラグを立てる
				else if( Key[ KEY_INPUT_DOWN ]  == 1 )  //下ボタンが押されたら
                    ch.muki=2;         //下向きフラグを立てる
				else if( Key[ KEY_INPUT_RIGHT]  == 1 )  //右ボタンが押されたら
                    ch.muki=3;         //右向きフラグを立てる
				else                                    //何のボタンも押されてなかったら
                    ch.walking_flag=0; //歩かないフラグを立てる
				if(ch.walking_flag==1){    //もし歩くなら
					if(can_or_cannot(ch.x,ch.y,ch.muki)==1){//行き先が歩けないなら
						ch.walking_flag=0;                  //歩かないフラグを立てる。
					}
				}
				if(break_box(ch.x,ch.y,ch.muki)==1 && (Key[KEY_INPUT_UP]==1||Key[KEY_INPUT_LEFT]==1||Key[KEY_INPUT_DOWN]==1||Key[KEY_INPUT_RIGHT]==1)){//壁が壊せるか
					break_box_push(ch.x,ch.y,ch.muki);
					if(break_can_or_cannot(ch.x,ch.y,ch.muki)==1)
						break_box_attack(ch.x,ch.y,ch.muki);//壁を壊す
				}
			}

			if(ch.muki != tenkan && tenkan_wait<=0){//方向転換処理
				tenkan = ch.muki;
				ch.walking_flag = 0;
				tenkan_wait = 4;
			}else if(tenkan_wait>0){ch.walking_flag = 0;tenkan_wait--;}
 
        if(ch.walking_flag==1){        //歩くフラグが立っていたら
			ch.now_x = ch.x;
			ch.now_y = ch.y;
            if	   (ch.muki==0)        //上向きならch.y座標を減らす
                    ch.y-=2;
            else if(ch.muki==1)        //左向きならch.x座標を減らす
                    ch.x-=2;
            else if(ch.muki==2)        //下向きならch.y座標を増やす
                    ch.y+=2;
            else if(ch.muki==3)        //右向きならch.x座標を増やす
                    ch.x+=2;
        }
		if(ch_flag[0] == 0 && (ch.x%32!=0 || ch.y%32!=0)){//キャラ判定用フラグ
			set_chara_hantei(ch.now_x,ch.now_y,ch.muki);
			ch_flag[0] = 1;
		}
		if(ch_flag[0] == 1 && (ch.x%32==0 && ch.y%32==0)){
			ch_flag[0] = 0;
		}
		
		if(MP_heal_c >0){MP_heal_c --;}//MP回復カウント

		if(MP_heal_c <= 0 && ch.MP <10){ch.MP ++; MP_heal_c =25;}//MP回復

		if(Key[ KEY_INPUT_Z] == 1 && ch.x%32==0 && ch.y%32==0 && ch.MP >= 1){//弱壁設置 壁じゃないとき置けるようにすること　MP消費実装
			ch.now_x = ch.x;
			ch.now_y = ch.y;
			if(create_box_1(ch.now_x,ch.now_y,ch.muki) == 1){
				ch.MP --;
				MP_heal_c = 50;
			}
		}
		if(Key[ KEY_INPUT_X] == 1 && ch.x%32==0 && ch.y%32==0 && ch.MP >= 2){//中壁設置 壁じゃないとき置けるようにすること　MP消費実装
			ch.now_x = ch.x;
			ch.now_y = ch.y;
			if(create_box_2(ch.now_x,ch.now_y,ch.muki) == 1){
				ch.MP = ch.MP - 2;
				MP_heal_c = 100;
			}
		}
		if(Key[ KEY_INPUT_C] == 1 && ch.x%32==0 && ch.y%32==0 && ch.MP >= 3){//強壁設置 壁じゃないとき置けるようにすること　MP消費実装
			ch.now_x = ch.x;
			ch.now_y = ch.y;
			if(create_box_3(ch.now_x,ch.now_y,ch.muki) == 1){
				ch.MP = ch.MP - 3;
				MP_heal_c = 150;
			}
		}
		if(Key[ KEY_INPUT_P] == 1 && ch.x%32==0 && ch.y%32==0){//一時中断用
			pause(&ch.x,&ch.y,&ch.muki,&ch.img,&ch.life,&ch.MP,&font_color,&end_time,&now_time,enemy);
			SetFontSize( 18 ) ;
			font_color = GetColor( 255 , 0 , 0 ) ;
			WaitTimer(200);
		}
		for(i=0;i<10;i++){
			if((ene+i)->enemy_on == 1){//enemy[i]がでていれば
				if((ene+i)->stop_count <= 30){//enemy[i]が壁はまりしてなければ
					if(enemy_base(&ch.x,&ch.y,&ch.life,(ene+i),&ch_flag[i+1])==1){//敵移動関数呼び出し
						(ene+i)->stop_count = (ene+i)->stop_count + 5;
					}else{
						(ene+i)->stop_count = 0;
					}
				}else{//壁はまりしていたら
					enemy_rand_walk(&ch.x,&ch.y,&ch.life,(ene+i),&ch_flag[i+1]);
					(ene+i)->stop_count --;
					if((ene+i)->stop_count <= 30) (ene+i)->stop_count = 0;
				}
			}else{
				if((end_time - now_time) <= 30+(10*i) && (ene+i)->enemy_on == 0){//enemy[i]スイッチ
					(ene+i)->enemy_on = 1;
					map->chara[(ene+i)->now_y/32][(ene+i)->now_x/32] = 8;//mapへの敵キャラ初期配置
				}
			}
		}
		if(ch.life<1){//ゲームオーバー判定
			game_over(&ch.x,&ch.y,&ch.muki,&ch.img,&ch.life,&ch.MP,&font_color,&end_time,&now_time,enemy);
			map->chara[ch.now_y/32][ch.now_x/32] = 0;
			switch(stage_no){//ゲームオーバー時ステージ初期化
				case 1:map1 = map7; break;
				case 2:map2 = map7;	break;
				case 3:map3 = map7;	break;
				case 4:map4 = map7;	break;
				case 5:map5 = map7;	break;
				case 6:map6 = map7;	break;
			}
			stock = stock - 1;
			map = &map0;
			return(90);
		}
		if(ch.life>=1 && (end_time - now_time) <= 0){//クリア判定
			DrawGraph(160,160,gazou.item[stage_no-1],TRUE );
			time_stop_flag = 1;
		}
		if(time_stop_flag==1&&(ch.x==160&&ch.y==160)){//ステージクリア
			stage_clear(&ch.x,&ch.y,&ch.muki,&ch.img,&ch.life,&ch.MP,&font_color,&end_time,&now_time,&clear_flag[stage_no-1],enemy);
		}
        ch.img=gazou.image[(ch.x%32+ch.y%32)/8 + ch.muki*4];            //画像をセット
        DrawGraph( ch.x , ch.y , ch.img , TRUE ) ;//画像を描画
		for(i=0;i<10;i++){
			if((ene+i)->enemy_on == 1){//enemy[i]がでていれば描写
				(ene+i)->img=gazou.teki[((ene+i)->x%32+(ene+i)->y%32)/8 + (ene+i)->muki*4];
				DrawGraph( (ene+i)->x , (ene+i)->y , (ene+i)->img , TRUE ) ;
			}
		}
        ScreenFlip();
		}
	if(Key[KEY_INPUT_ESCAPE])DxLib_End();
	map = &map0;
	return(ch.life);
}